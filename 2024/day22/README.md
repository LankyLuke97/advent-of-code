# Advent of Code 2024
## Day 22
### Part 1
Appearing in a jungle, a monkey immediately steals the teleportation device. The monkey is willing to trade it back for an absurd number of bananas, which means we'll need to exploit the Monkey Exchange Market.  

The monkeys are today buying good hiding spots, which is fortuitous for us; we know a number of hood hiding spots from our time spent here previously. We just need to maximise the amount we sell.  

The monkeys use pseudorandom numbers for their prices, with the price they are willilng to pay derived from the previous time step. Each monkey starts with a secret number, which evolves in the following manner:
```
let n be the secret number
n = ((n * 64) XOR n) % 16777216
n = ((n // 32) XOR n) % 16777216
n = ((n * 2048) XOR n) % 16777216
```
In a single day, the buyers have time to generate 2000 secret numbers from their initial one. What is the sum of the 2000th secret number generated by each buyer?
### Solution
Not these monkeys again; I remember these guys from 2022, though I think the trouble I had with their problem was just due to integer overflor in C++.  

There's not too much to discuss for this part, once you unpick the instructions. For each number, I run 2000 iterations of the process described. The interesting bit of this is that all of the steps can be done through bit operations, since the numbers involved are all powers of 2.  

Each step is a multiply or divide *and truncate*, followed by mixing (XOR the result with the original number) and pruning (modulo 16777216).  

Multiply by 64? That's a bit shift left by 6. Divide by 5 and truncate? That's a right shift by 5. Multiply by 2048? Left by 11. And a nifty trick I saw for day 17 is that the modulo of a power of 2, let's say ```num % 2^x```, is equivalent to ```num & (2^x -1)```; this makes intuitive sense once you look at it.  

I don't know how much quicker this all was than just doing the basic maths operations - it may well be that the compiler would have performed the exact same operations behind the scenes - but still, satisfying.  
### Part 2
Of course, these numbers aren't the amount the monkeys are willing to pay. At each time step, the price the monkey is willing to pay is the final digit of their secret number.  

We don't speak enough monkey to negotiate, but one of the historians knows enough to instruct another monkey to negotiate for us.  

This monkey will watch the prices of the other monkeys; more specifically, the changes in prices for each monkey. We can give him one single sequence of 4 price changes to look out for; he will then, the first time this sequence of changes comes up for each buyer, sell at whatever price the monkey is currently offering. If the sequence doesn't come up in 2000 secret numbers, then he won't sell to that monkey.  

What is the most bananas we can get with a single sequence of four price changes across all the monkeys?
### Solution
Ok, so the the first step to this problem is the same as for the previous part, which is to simulate 2000 'secret numbers' for each monkey.  

The first difference is that I'll also need to track the last four changes and the associated price changes; I do this in a double-ended queue with a max size of four (I later saw someone use something from itertools, I believe, that just takes sets of 4 items in a rolling manner across the iterable, which is a nice one to know about). To calculate the change each iteration, I'll also need to save the previous price.  

So, I iterate through as before and am now calculating the price changes. I create a dictionary of tuples of price changes and the price offered when that sequence has been seen. I only store the first such instance of a sequence of price changes, since our monkey negotiator will sell at the first such instance. This is all done in a helper function that returns out this dictionary.  

I pass each input line to this function one at a time. Then, I take the output dictionary of sequences to prices from each one, and create an overarching dictionary that represents all the monkeys. The keys of this dictionary are still the tuples of prices changes, but the values are instead a cumulative sum of the price received from each monkey the first time that sequence is seen.  

The answer is then trivial to find, but selecting the max over the values of this dictionary.

**Part 1:** *1,037.97 ms*  
**Part 2:** *3,356.08 ms*  

[Back to all days](/2024)